{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Strawberry integration with Django.</p> <p>makes it easier to build better web apps more quickly and with less code.</p> <p> </p>"},{"location":"#supported-features","title":"Supported features","text":"<ul> <li> GraphQL type generation from models</li> <li> Filtering, pagination and ordering</li> <li> Basic create, retrieve, update and delete (CRUD) types and mutations</li> <li> Basic Django auth support, current user query, login and logout mutations</li> <li> Django sync and async views</li> <li> Permission extension using django's permissioning system</li> <li> Relay support with automatic resolvers generation</li> <li> Query optimization to improve performance and avoid common pitfalls (e.g n+1)</li> <li> Debug Toolbar integration with graphiql to display metrics like SQL queries</li> <li> Unit test integration</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install strawberry-graphql-django\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"models.py<pre><code>from django.db import models\nfrom django_choices_field import TextChoicesField\n\nclass FruitCategory(models.TextChoices):\n    CITRUS = \"citrus\", \"Citrus\"\n    BERRY = \"berry\", \"Berry\"\n\nclass Fruit(models.Model):\n    \"\"\"A tasty treat\"\"\"\n    name = models.CharField(\n        max_length=20,\n    )\n    category = TextChoicesField(\n        choices_enum=FruitCategory,\n    )\n    color = models.ForeignKey(\n        \"Color\",\n        on_delete=models.CASCADE,\n        related_name=\"fruits\",\n        blank=True,\n        null=True,\n    )\n\nclass Color(models.Model):\n    name = models.CharField(\n        max_length=20,\n        help_text=\"field description\",\n    )\n</code></pre> types.py<pre><code>import strawberry\nfrom strawberry import auto\n\nfrom . import models\n\n@strawberry.django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n    category: auto\n    color: \"Color\"\n\n@strawberry.django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n    fruits: list[Fruit]\n</code></pre> schema.py<pre><code>import strawberry\nfrom strawberry_django.optimizer import DjangoOptimizerExtension\n\nfrom .types import Fruit\n\n@strawberry.type\nclass Query:\n    fruits: list[Fruit] = strawberry.django.field()\n\nschema = strawberry.Schema(\n    query=Query,\n    extensions=[\n        DjangoOptimizerExtension,\n    ],\n)\n</code></pre> settings.py<pre><code>STRAWBERRY_DJANGO = {\n    \"FIELD_DESCRIPTION_FROM_HELP_TEXT\": True,\n    \"TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING\": True,\n}\n</code></pre> urls.py<pre><code>from django.urls import include, path\nfrom strawberry.django.views import AsyncGraphQLView\n\nfrom .schema import schema\n\nurlpatterns = [\n    path('graphql', AsyncGraphQLView.as_view(schema=schema)),\n]\n</code></pre> <p>Code above generates following schema.</p> schema.graphql<pre><code>enum FruitCategory {\n  CITRUS\n  BERRY\n}\n\n\"\"\"\nA tasty treat\n\"\"\"\ntype Fruit {\n  id: ID!\n  name: String!\n  category: FruitCategory!\n  color: Color\n}\n\ntype Color {\n  id: ID!\n  \"\"\"\n  field description\n  \"\"\"\n  name: String!\n  fruits: [Fruit!]\n}\n\ntype Query {\n  fruits: [Fruit!]!\n}\n</code></pre>"},{"location":"community-projects/","title":"Community Projects","text":"<p>Those are some community maintained projects worth mentioning:</p> Project Description  strawberry-django-plus  Additional features that are out of this project scope (deprecated since merged to this lib)  strawberry-django-jwt  JWT implementation with Strawberry and Django.  strawberry-django-auth  Authentication System for Django using Strawberry. <p>If you want your integration to be listed here, send us a Pull Request</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We use poetry to manage dependencies, to get started follow these steps:</p> <pre><code>git clone https://github.com/strawberry-graphql/strawberry-graphql-django.git\ncd strawberry-graphql-django\npoetry install\npoetry run pytest\n</code></pre> <p>This will install all the dependencies (including dev ones) and run the tests.</p>"},{"location":"contributing/#pre-commit","title":"Pre commit","text":"<p>We have a configuration for pre-commit, to add the hook run the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/#docs-setup-and-local-server","title":"Docs setup and local server","text":"<p>We use Material for MkDocs, you can read the documentation here</p> <pre><code>make serve-docs\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#how-to-access-django-request-object-in-resolvers","title":"How to access Django request object in resolvers?","text":"<p>The request object is accessible via the <code>info.context.request</code> object.</p> <pre><code>def resolver(root, info: Info):\n    request = info.context.request\n</code></pre>"},{"location":"faq/#how-to-access-the-current-user-object-in-resolvers","title":"How to access the current user object in resolvers?","text":"<p>The current user object is accessible via the <code>info.context.request.user</code> object.</p> <pre><code>def resolver(root, info: Info):\n    current_user = info.context.request.user\n</code></pre>"},{"location":"faq/#autocompletion-with-editors","title":"Autocompletion with editors","text":"<p>Some editors like VSCode may not be able to resolve symbols and types without explicit <code>strawberry.django</code> import. Adding following line to code fixes that problem.</p> <pre><code>import strawberry.django\n</code></pre>"},{"location":"faq/#example-project","title":"Example project?","text":"<p>See complete Django project from github repository folder examples/django.</p>"},{"location":"quick-start/","title":"Quick Start","text":"<p>This library provides a toolset for GraphQL schema generation from Django models.</p>"},{"location":"quick-start/#installing-the-package","title":"Installing the package","text":"<pre><code>pip install strawberry_graphql_django\n</code></pre> <p>The following optional dependencies are recommended to make the most of this integration:</p> <ul> <li>django-choices-field</li> <li>django-guardian</li> <li>django-debug-toolbar</li> </ul>"},{"location":"quick-start/#sample-project","title":"Sample project","text":"<p>Your boss asks you for a Django model called <code>Fruit</code>, which has two attributes, name and color.</p> models.py<pre><code>from django.db import models\n\nclass Fruit(models.Model):\n    name = models.CharField(max_length=20)\n    color = models.CharField(max_length=20)\n</code></pre> <p>Soon after that, your boss asks you to implement an API for that model so that everyone can access our great fruit database from all over the world.</p> <p>The <code>Fruit</code> model has name and color attributes and we want to publish both of them. The GraphQL output type for our model is generated by using the <code>strawberry_django.type</code> decorator. Both fields are char fields so we will need to use the built-in Python <code>str</code> type in our API.</p> types.py<pre><code>import strawberry_django\n\nfrom . import models\n\n@strawberry_django.type(models.Fruit)\nclass Fruit:\n    name: str\n    color: str\n</code></pre> <p>The last step is to generate the <code>Query</code> type and the <code>Schema</code>, which we can do using the core package <code>strawberry</code>.</p> schema.py<pre><code>import strawberry\nfrom strawberry_django.optimizer import DjangoOptimizerExtension\n\nfrom .types import Fruit\n\n@strawberry.type\nclass Query:\n    fruits: list[Fruit] = strawberry.django.field()\n\nschema = strawberry.Schema(\n    query=Query,\n    extensions=[\n        DjangoOptimizerExtension,  # not required, but highly recommended\n    ],\n)\n</code></pre> <p>Finally we add a <code>AsyncGraphQLView</code> view to our list of urls so that we can start making our first queries.</p> urls.py<pre><code>from django.urls import include, path\nfrom strawberry.django.views import AsyncGraphQLView\n\nfrom .schema import schema\n\nurlpatterns = [\n    path('graphql', AsyncGraphQLView.as_view(schema=schema)),\n]\n</code></pre> <p>After that, once the development server is running, you can read your fruits from the database through a GraphQL request.</p> query<pre><code>query {\n  fruits {\n    name\n    color\n  }\n}\n</code></pre> <p>And it would be returned like:</p> response<pre><code>{\n  fruits:\u00a0[\n    {\n      name: \"strawberry\",\n      color: \"red\"\n    }\n  ]\n}\n</code></pre>"},{"location":"quick-start/#model-relations","title":"Model Relations","text":"<p>Your boss wants the models to be more scalable. In particular, they think encoding <code>color</code> as a string is too limiting. Let's create another model called <code>Color</code> and add a foreign key relation between the <code>Fruit</code> and <code>Color</code> models.</p> models.py<pre><code>from django.db import models\nfrom django_choices_field import TextChoicesField\n\nclass FruitCategory(models.TextChoices):\n    CITRUS = \"citrus\", \"Citrus\"\n    BERRY = \"berry\", \"Berry\"\n\nclass Fruit(models.Model):\n    name = models.CharField(\n        max_length=20,\n    )\n    category = TextChoicesField(\n        choices_enum=FruitCategory,\n    )\n    color = models.ForeignKey(\n        \"Color\",\n        related_name='fruits',\n        on_delete=models.CASCADE,\n    )\n\nclass Color(models.Model):\n    name = models.CharField(max_length=20)\n</code></pre> <p>We also need to add a GraphQL Type for <code>Color</code> and modify the existing <code>Fruit</code> type to reflect our changes. The <code>auto</code> field type is used for automatic type resolution. <code>strawberry_django</code> goes through all fields and resolves field types. It also generates resolvers for relation fields for you.</p> types.py<pre><code>import strawberry_django\nfrom strawberry import auto\n\nfrom . import models\n\n@strawberry_django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n    category: auto\n    color: \"Color\"\n\n@strawberry_django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n    fruits: list[Fruit]\n</code></pre> <p>This generates the following schema:</p> schema.graphql<pre><code>enum FruitCategory {\n  CITRUS\n  BERRY\n}\n\ntype Color {\n  id: ID!\n  name: String!\n  fruits: [Fruit!]\n}\n\ntype Fruit {\n  id: ID!\n  name: String!\n  category: FruitCategory\n  color: Color!\n}\n\ntype Query {\n  fruits: [Fruit!]!\n}\n</code></pre> <p>Now you can start making queries and request all fruits and their colors from the database.</p> query<pre><code>query {\n  fruits {\n    name\n    category\n    color {\n      name\n    }\n  }\n}\n</code></pre> <p>The response would come like this:</p> response<pre><code>{\n  fruits:\u00a0[\n    {\n      name: \"strawberry\",\n      category: \"BERRY\",\n      color: { name: \"red\" }\n    },\n    {\n      name: \"banana\",\n      category: \"BERRY\",\n      color: { name: \"yellow\" }\n    }\n  ]\n}\n</code></pre>"},{"location":"quick-start/#next-steps","title":"Next steps","text":"<ol> <li>Defining more Django Types</li> <li>Define Fields inside those Types</li> <li>Serve your API using ASGI or WSGI</li> <li>Define filters for your fields</li> <li>Define orderings for your fields</li> <li>Define pagination for your fields</li> <li>Define queries for your schema</li> <li>Define mutations for your schema</li> <li>Define subscriptions for your schema</li> <li>Enable the Query Optimizer extension for performance improvement</li> <li>Use the relay integration for advanced pagination and model refetching</li> <li>Protect your fields using the Permission Extension</li> <li>Write unit tests for your schema</li> </ol>"},{"location":"guide/authentication/","title":"Authentication","text":"<p>Warning</p> <p>This solution is enough for web browsers, but will not work for clients that doesn't have a way to store cookies in it (e.g. mobile apps). For those it is recommended to use token authentication methods. JWT can be used with strawberry-django-jwt lib.</p> <p><code>strawberry_django</code> provides mutations to get authentication going right away. The <code>auth.register</code> mutation performs password validation using Django's <code>validate_password</code> method.</p> types.py<pre><code>import strawberry\nfrom strawberry import auto\nfrom django.contrib.auth import get_user_model\n\n@strawberry.django.type(get_user_model())\nclass User:\n    username: auto\n    email: auto\n\n@strawberry.django.input(get_user_model())\nclass UserInput:\n    username: auto\n    password: auto\n</code></pre> schema.py<pre><code>from strawberry.django import auth\nfrom .types import User, UserInput\n\n@strawberry.type\nclass Query:\n    me: User = auth.current_user()\n\n@strawberry.type\nclass Mutation:\n    login: User = auth.login()\n    logout = auth.logout()\n    register: User = auth.register(UserInput)\n</code></pre>"},{"location":"guide/fields/","title":"Defining Fields","text":"<p>Tip</p> <p>It is highly recommended to enable the Query Optimizer Extension for improved performance and avoid some common pitfalls (e.g. the <code>n+1</code> issue)</p> <p>Fields can be defined manually or <code>auto</code> type can be used for automatic type resolution. All basic field types and relation fields are supported out of the box. If you use a library that defines a custom field you will need to define an equivalent type such as <code>str</code>, <code>float</code>, <code>bool</code>, <code>int</code> or <code>id</code>.</p> types.py<pre><code>import strawberry\nfrom strawberry import auto\n\n@strawberry.django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n\n# equivalent type, inferred by `strawberry`\n\n@strawberry.django.type(models.Fruit)\nclass Fruit2:\n    id: strawberry.ID\n    name: str\n</code></pre> <p>Tip</p> <p>For choices using Django's TextChoices/IntegerChoices it is recommented using the django-choices-field integration enum handling.</p>"},{"location":"guide/fields/#relationships","title":"Relationships","text":"<p>All one-to-one, one-to-many, many-to-one and many-to-many relationship types are supported, and the many-to-many relation is described using the <code>typing.List</code> annotation. The default resolver of <code>strawberry.django.fields()</code> resolves the relationship based on given type information.</p> types.py<pre><code>from typing import List\n\n@strawberry.django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n    color: \"Color\"\n\n\n@strawberry.django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n    fruits: List[Fruit]\n</code></pre> <p>Note that all relations can naturally trigger the n+1 problem. To avoid that, you can either enable the Optimizer Extension which will automatically solve some general issues for you, or even use Data Loaders for more complex situations.</p>"},{"location":"guide/fields/#field-customization","title":"Field customization","text":"<p>All Django types are encoded using the <code>strawberry.django.field()</code> field type by default. Fields can be customized with various parameters.</p> types.py<pre><code>@strawberry.django.type(models.Color)\nclass Color:\n    another_name: auto = strawberry.django.field(field_name='name')\n    internal_name: auto = strawberry.django.field(\n        name='fruits',\n        field_name='fruit_set',\n        filters=FruitFilter,\n        order=FruitOrder,\n        pagination=True,\n        description=\"A list of fruits with this color\"\n    )\n</code></pre>"},{"location":"guide/fields/#defining-types-for-auto-fields","title":"Defining types for auto fields","text":"<p>When using <code>strawberry.auto</code> to resolve a field's type, Strawberry Django uses a dict that maps each django field field type to its proper type. e.g.:</p> <pre><code>{\n    models.CharField: str,\n    models.IntegerField: int,\n    ...,\n}\n</code></pre> <p>If you are using a custom django field that is not part of the default library, or you want to use a different type for a field, you can do that by overriding its value in the map, like:</p> <pre><code>from typing import NewType\n\nimport strawberry\nimport strawberry_django\n\nSlug = strawberry.scalar(\n    NewType(\"Slug\", str),\n    serialize=lambda v: v,\n    parse_value=lambda v: v,\n)\n\n@strawberry.type\nclass MyCustomFileType:\n    ...\n\nstrawberry_django.field_type_map.update({\n    models.SlugField: Slug,\n    models.FileField: MyCustomFileType,\n})\n</code></pre>"},{"location":"guide/fields/#including-excluding-django-model-fields-by-name","title":"Including / excluding Django model fields by name","text":"<p>Warning</p> <p>These new keywords should be used with caution, as they may inadvertently lead to exposure of unwanted data. Especially with <code>fields=\"__all__\"</code> or <code>exclude</code>, sensitive model attributes may be included and made available in the schema without your awareness.</p> <p><code>strawberry.django.type</code> includes two optional keyword fields to help you populate fields from the Django model, <code>fields</code> and <code>exclude</code>.</p> <p>Valid values for <code>fields</code> are:</p> <ul> <li><code>__all__</code> to assign <code>strawberry.auto</code> as the field type for all model fields.</li> <li><code>[&lt;List of field names&gt;]</code> to assign <code>strawberry.auto</code> as the field type for the enumerated fields. These can be combined with manual type annotations if needed.</li> </ul> All Fields<pre><code>@strawberry.django.type(models.Fruit, fields=\"__all__\")\nclass FruitType:\n    pass\n</code></pre> Enumerated Fields<pre><code>@strawberry.django.type(models.Fruit, fields=[\"name\", \"color\"])\nclass FruitType:\n    pass\n</code></pre> Overriden Fields<pre><code>@strawberry.django.type(models.Fruit, fields=[\"color\"])\nclass FruitType:\n    name: str\n</code></pre> <p>Valid values for <code>exclude</code> are:</p> <ul> <li><code>[&lt;List of field names&gt;]</code> to exclude from the fields list. All other Django model fields will included and have <code>strawberry.auto</code> as the field type. These can also be overriden if another field type should be assigned. An empty list is ignored.</li> </ul> Exclude Fields<pre><code>@strawberry.django.type(models.Fruit, exclude=[\"name\"])\nclass FruitType:\n    pass\n</code></pre> Overriden Exclude Fields<pre><code>@strawberry.django.type(models.Fruit, exclude=[\"name\"])\nclass FruitType:\n    color: int\n</code></pre> <p>Note that <code>fields</code> has precedence over <code>exclude</code>, so if both are provided, then <code>exclude</code> is ignored.</p>"},{"location":"guide/fields/#overriding-the-field-class-advanced","title":"Overriding the field class (advanced)","text":"<p>If in your project, you want to change/add some of the standard <code>strawberry.django.field()</code> behaviour, it is possible to use your own custom field class when decorating a <code>strawberry.django.type</code> with the <code>field_cls</code> argument, e.g.</p> types.py<pre><code>class CustomStrawberryDjangoField(StrawberryDjangoField):\n    \"\"\"Your custom behaviour goes here.\"\"\"\n\n@strawberry_django.type(User, field_cls=CustomStrawberryDjangoField)\nclass UserType:\n    # Each of these fields will be an instance of `CustomStrawberryDjangoField`.\n    id: int\n    name: auto\n\n\n@strawberry.type\nclass UserQuery:\n    # You can directly create your custom field class on a plain strawberry type\n    user: UserType = CustomStrawberryDjangoField()\n</code></pre> <p>In this example, each of the fields of the <code>UserType</code> will be automatically created by <code>CustomStrawberryDjangoField</code>, which may implement anything from custom pagination of relationships to altering the field permissions.</p>"},{"location":"guide/filters/","title":"Filtering","text":"<p>It is possible to define filters for Django types, which will be converted into <code>.filter(...)</code> queries for the ORM:</p> types.py<pre><code>import strawberry\nfrom strawberry import auto\n\n@strawberry.django.filter(models.Fruit)\nclass FruitFilter:\n    id: auto\n    name: auto\n\n@strawberry.django.type(models.Fruit, filters=FruitFilter)\nclass Fruit:\n    ...\n</code></pre> <p>The code above would generate following schema:</p> schema.graphql<pre><code>input FruitFilter {\n  id: ID\n  name: String\n  AND: FruitFilter\n  OR: FruitFilter\n  NOT: FruitFilter\n}\n</code></pre> <p>Tip</p> <p>If you are using the relay integration and working with types inheriting from <code>relay.Node</code> and <code>GlobalID</code> for identifying objects, you might want to set <code>MAP_AUTO_ID_AS_GLOBAL_ID=True</code> in your strawberry django settings to make sure <code>auto</code> fields gets mapped to <code>GlobalID</code> on types and filters.</p>"},{"location":"guide/filters/#lookups","title":"Lookups","text":"<p>Lookups can be added to all fields with <code>lookups=True</code>, which will add more options to resolve each type. For example:</p> types.py<pre><code>@strawberry.django.filter(models.Fruit, lookups=True)\nclass FruitFilter:\n    id: auto\n    name: auto\n</code></pre> <p>The code above would generate the following schema:</p> schema.graphql<pre><code>input StrFilterLookup {\n  exact: String\n  iExact: String\n  contains: String\n  iContains: String\n  inList: [String!]\n  gt: String\n  gte: String\n  lt: String\n  lte: String\n  startsWith: String\n  iStartsWith: String\n  endsWith: String\n  iEndsWith: String\n  range: [String!]\n  isNull: Boolean\n  regex: String\n  iRegex: String\n  nExact: String\n  nIExact: String\n  nContains: String\n  nIContains: String\n  nInList: [String!]\n  nGt: String\n  nGte: String\n  nLt: String\n  nLte: String\n  nStartsWith: String\n  nIStartsWith: String\n  nEndsWith: String\n  nIEndsWith: String\n  nRange: [String!]\n  nIsNull: Boolean\n  nRegex: String\n  nIRegex: String\n}\n\ninput IDFilterLookup {\n  exact: String\n  iExact: String\n  contains: String\n  iContains: String\n  inList: [String!]\n  gt: String\n  gte: String\n  lt: String\n  lte: String\n  startsWith: String\n  iStartsWith: String\n  endsWith: String\n  iEndsWith: String\n  range: [String!]\n  isNull: Boolean\n  regex: String\n  iRegex: String\n  nExact: String\n  nIExact: String\n  nContains: String\n  nIContains: String\n  nInList: [String!]\n  nGt: String\n  nGte: String\n  nLt: String\n  nLte: String\n  nStartsWith: String\n  nIStartsWith: String\n  nEndsWith: String\n  nIEndsWith: String\n  nRange: [String!]\n  nIsNull: Boolean\n  nRegex: String\n  nIRegex: String\n}\n\ninput FruitFilter {\n  id: IDFilterLookup\n  name: StrFilterLookup\n  AND: FruitFilter\n  OR: FruitFilter\n  NOT: FruitFilter\n}\n</code></pre> <p>Single-field lookup can be annotated with the <code>FilterLookup</code> generic type.</p> types.py<pre><code>from strawberry.django.filters import FilterLookup\n\n@strawberry.django.filter(models.Fruit)\nclass FruitFilter:\n    name: FilterLookup[str]\n</code></pre>"},{"location":"guide/filters/#filtering-over-relationships","title":"Filtering over relationships","text":"types.py<pre><code>@strawberry.django.filter(models.Fruit)\nclass FruitFilter:\n    id: auto\n    name: auto\n    color: \"ColorFilter\"\n\n@strawberry.django.filter(models.Color)\nclass ColorFilter:\n    id: auto\n    name: auto\n</code></pre> <p>The code above would generate following schema:</p> schema.graphql<pre><code>input ColorFilter {\n  id: ID\n  name: String\n  AND: ColorFilter\n  OR: ColorFilter\n  NOT: ColorFilter\n}\n\ninput FruitFilter {\n  id: ID\n  name: String\n  color: ColorFilter\n  AND: FruitFilter\n  OR: FruitFilter\n  NOT: FruitFilter\n}\n</code></pre>"},{"location":"guide/filters/#custom-filters-and-overriding-default-filtering-methods","title":"Custom filters and overriding default filtering methods","text":"<p>You can define custom filter methods and override default filter methods by defining your own resolver.</p> types.py<pre><code>@strawberry.django.filter(models.Fruit)\nclass FruitFilter:\n    is_banana: bool | None\n\n    def filter_is_banana(self, queryset):\n        if self.is_banana in (None, strawberry.UNSET):\n            return queryset\n\n        if self.is_banana:\n            queryset = queryset.filter(name='banana')\n        else:\n            queryset = queryset.exclude(name='banana')\n\n        return queryset\n</code></pre>"},{"location":"guide/filters/#overriding-the-default-filter-method","title":"Overriding the default <code>filter</code> method","text":"<p>For overriding the default filter logic you can provide the filter method. Note that this completely disables the default filtering, which means your custom method is responsible for handling all filter-related operations.</p> types.py<pre><code>@strawberry.django.filter(models.Fruit)\nclass FruitFilter:\n    is_apple: bool | None\n\n    def filter(self, queryset):\n        if self.is_apple:\n            return queryset.filter(name='apple')\n        return queryset.exclude(name='apple')\n</code></pre>"},{"location":"guide/filters/#adding-filters-to-types","title":"Adding filters to types","text":"<p>All fields and CUD mutations inherit filters from the underlying type by default. So, if you have a field like this:</p> types.py<pre><code>@strawberry.django.type(models.Fruit, filters=FruitFilter)\nclass Fruit:\n    ...\n\n@strawberry.type\nclass Query:\n    fruits: list[Fruit] = strawberry.django.field()\n</code></pre> <p>The <code>fruits</code> field will inherit the <code>filters</code> of the type in the same way as if it was passed to the field.</p>"},{"location":"guide/filters/#adding-filters-directly-into-a-field","title":"Adding filters directly into a field","text":"<p>Filters added into a field override the default filters of this type.</p> schema.py<pre><code>@strawberry.type\nclass Query:\n    fruits: list[Fruit] = strawberry.django.field(filters=FruitFilter)\n</code></pre>"},{"location":"guide/mutations/","title":"Mutations","text":""},{"location":"guide/mutations/#getting-started","title":"Getting started","text":"<p>Mutations can be defined the same way as strawberry's mutations, but instead of using <code>@strawberry.mutation</code>, use <code>@strawberry_django.mutation</code>.</p> <p>Here are the differences between those:</p> <ul> <li>Strawberry Django's mutation will be sure that the mutation is executed in an async safe   environment, meaning that if you are running ASGI and you define a <code>sync</code> resolver, it will   automatically be wrapped in a <code>sync_to_async</code> call.</li> <li>It will better integrate with the permissioning integration</li> <li>It has an option to automatically handle common django errors and return them   in a standardized way (more on that below)</li> </ul>"},{"location":"guide/mutations/#django-errors-handling","title":"Django errors handling","text":"<p>When defining a mutation you can pass <code>handle_django_errors=True</code> to make it handle common django errors, such as <code>ValidationError</code>, <code>PermissionDenied</code> and <code>ObjectDoesNotExist</code>:</p> types.py<pre><code>@strawberry.type\nclass Mutation:\n    @strawberry.django.mutation(handle_django_errors=True)\n    def create_fruit(self, name: str, color: str) -&gt; Fruit:\n        if not is_valid_color(color):\n            raise ValidationError(\"The color is not valid\")\n\n        # Creation can also raise ValidationError, if the `name` is\n        # larger than its allowed `max_length` for example.\n        fruit = models.Fruit.objects.create(name=name)\n        return cast(Fruit, fruit)\n</code></pre> <p>The code above would generate following schema:</p> schema.graphql<pre><code>enum OperationMessageKind {\n  INFO\n  WARNING\n  ERROR\n  PERMISSION\n  VALIDATION\n}\n\ntype OperationInfo {\n  \"\"\"List of messages returned by the operation.\"\"\"\n  messages: [OperationMessage!]!\n}\n\ntype OperationMessage {\n  \"\"\"The kind of this message.\"\"\"\n  kind: OperationMessageKind!\n\n  \"\"\"The error message.\"\"\"\n  message: String!\n\n  \"\"\"\n  The field that caused the error, or `null` if it isn't associated with any particular field.\n  \"\"\"\n  field: String\n\n  \"\"\"The error code, or `null` if no error code was set.\"\"\"\n  code: String\n}\n\ntype Fruit {\n  name: String!\n  color: String!\n}\n\nunion CreateFruitPayload = Fruit | OperationInfo\n\nmutation {\n  createFruit(\n    name: String!\n    color: String!\n  ): CreateFruitPayload!\n}\n</code></pre> <p>Tip</p> <p>If all or most of your mutations use this behaviour, you can change the default behaviour for <code>handle_django_errors</code> by setting <code>MUTATIONS_DEFAULT_HANDLE_ERRORS=True</code>  in your strawberry django settings</p>"},{"location":"guide/mutations/#input-mutations","title":"Input mutations","text":"<p>Those are defined using <code>@strawberry_django.input_mutation</code> and act the same way as the <code>@strawberry_django.mutation</code>, the only difference being that it injects an InputMutationExtension in the field, which converts its arguments in a new type (check the extension's docs for more information).</p>"},{"location":"guide/mutations/#cud-mutations","title":"CUD mutations","text":"<p>The following CUD mutations are provided by this lib:</p> <ul> <li><code>strawberry_django.mutations.create</code>: Will create the model using the data from the given input</li> <li><code>strawberry_django.mutations.update</code>: Will update the model using the data from the given input</li> <li><code>strawberry_django.mutations.delete</code>: Will delete the model using the id from the given input</li> </ul> <p>A basic example would be:</p> types.py<pre><code>import strawberry\nfrom strawberry_django import mutations, NodeInput\nfrom strawberry.relay import Node\n\n\n\n@strawberry_django.type(SomeModel)\nclass SomeModelType(Node):\n    name: strawberry.auto\n\n@strawberry_django.input(SomeModel)\nclass SomeModelInput:\n    name: strawberry.auto\n\n\n@strawberry_django.partial(SomeModel)\nclass SomeModelInputPartial(NodeInput):\n    name: strawberry.auto\n\n@strawberry.type\nclass Mutation:\n    create_model: SomeModelType = mutations.create(SomeModelInput)\n    update_model: SomeModelType = mutations.update(SomeModelInputPartial)\n    delete_model: SomeModelType = mutations.delete(NodeInput)\n</code></pre> <p>Some things to note here:</p> <ul> <li>Those CUD mutations accept the same arguments as <code>@strawberry_django.mutation</code>   accepts. This allows you to pass <code>handle_django_errors=True</code> to it for example.</li> <li>The mutation will receive the type in an argument named <code>\"data\"</code> by default.   To change it to <code>\"info\"</code> for example, you can change it by passing   <code>argument_name=\"info\"</code> to the mutation, or set <code>MUTATIONS_DEFAULT_ARGUMENT_NAME=\"info\"</code>   in your strawberry django settings to make it the default when not provided.</li> </ul>"},{"location":"guide/mutations/#filtering","title":"Filtering","text":"<p>Danger</p> <p>This is totally discouraged as it allows for any issue with the filters to be able to alter your whole model collection.</p> <p>You have been warned!</p> <p>Filters can be added to update and delete mutations. More information in the filtering section.</p> schema.py<pre><code>from strawberry_django import mutations\n\n@strawberry.type\nclass Mutation:\n    updateFruits: List[Fruit] = mutations.update(FruitPartialInput, filters=FruitFilter)\n    deleteFruits: List[Fruit] = mutations.delete(filters=FruitFilter)\n\nschema = strawberry.Schema(mutation=Mutation)\n</code></pre>"},{"location":"guide/optimizer/","title":"Query Optimizer","text":""},{"location":"guide/optimizer/#features","title":"Features","text":"<p>The query optimizer is a must-have extension for improved performance of your schema. What it does:</p> <ol> <li>Call QuerySet.select_related()    on all selected foreign key relations by the query to avoid requiring an extra query to retrieve those</li> <li>Call QuerySet.prefetch_related()    on all selected many-to-one/many-to-many relations by the query to avoid requiring an extra query to retrieve those.</li> <li>Call QuerySet.only()    on all selected fields to reduce the database payload and only requesting what is actually being    selected</li> <li>Call QuerySet.annotate()    to support any passed annotations    of Query Expressions.</li> </ol> <p>Those are specially useful to avoid some common GraphQL pitfalls, like the famous <code>n+1</code> issue.</p>"},{"location":"guide/optimizer/#enabling-the-extension","title":"Enabling the extension","text":"<p>The automatic optimization can be enabled by adding the <code>DjangoOptimizerExtension</code> to your strawberry's schema config.</p> schema.py<pre><code>import strawberry\nfrom strawberry_django.optimizer import DjangoOptimizerExtension\n\nschema = strawberry.Schema(\n    Query,\n    extensions=[\n        # other extensions...\n        DjangoOptimizerExtension,\n    ]\n)\n</code></pre>"},{"location":"guide/optimizer/#usage","title":"Usage","text":"<p>The optimizer will try to optimize all types automatically by introspecting it. Consider the following example:</p> models.py<pre><code>class Artist(models.Model):\n    name = models.CharField()\n\n\nclass Album(models.Moodel):\n    name = models.CharField()\n    release_date = models.DateTimeField()\n    artist = models.ForeignKey(\"Artist\", related_name=\"albums\")\n\n\nclass Song(models.Model):\n    name = model.CharField()\n    duration = models.DecimalField()\n    album = models.ForeignKey(\"Album\", related_name=\"songs\")\n</code></pre> types.py<pre><code>import strawberry\nimport strawberry.django\n\n@strawberry.django.type(Artist)\nclass ArtistType:\n    name: auto\n    albums: list[\"AlbumType\"]\n    albums_count: int = strawberry.django.field(annotate=Count(\"albums\"))\n\n\n@strawberry.django.type(Album)\nclass AlbumType:\n    name: auto\n    release_date: auto\n    artist: ArtistType\n    songs: list[\"SongType\"]\n\n\n@strawberry.django.type(Song)\nclass SongType:\n    name: auto\n    duration: auto\n    album_type: AlbumType\n\n\n@strawberry.type\nclass Query:\n    artist: Artist = strawberry.django.field()\n    songs: List[SongType] = strawberry.django.field()\n</code></pre> <p>Querying for <code>artist</code> and <code>songs</code> like this:</p> schema.graphql<pre><code>query {\n  artist {\n    id\n    name\n    albums {\n      id\n      name\n      songs {\n        id\n        name\n      }\n    }\n    albumsCount\n  }\n  song {\n    id\n    album\n    id\n    name\n    artist {\n      id\n      name\n      albums {\n        id\n        name\n        release_date\n      }\n    }\n  }\n}\n</code></pre> <p>Would produce an ORM query like this:</p> <pre><code># For \"artist\" query\nArtist.objects.all().only(\"id\", \"name\").prefetch_related(\n    Prefetch(\n        \"albums\",\n        queryset=Album.objects.all().only(\"id\", \"name\").prefetch_related(\n            \"songs\",\n            Song.objects.all().only(\"id\", \"name\"),\n        )\n    ),\n).annotate(\n    albums_count=Count(\"albums\")\n)\n\n# For \"songs\" query\nSong.objects.all().only(\n    \"id\",\n    \"album\",\n    \"album__id\",\n    \"album__name\",\n    \"album__release_date\",  # Note about this below\n    \"album__artist\",\n    \"album__artist__id\",\n).select_related(\n    \"album\",\n    \"album__artist\",\n).prefetch_related(\n    \"album__artist__albums\",\n    Prefetch(\n        \"albums\",\n        Album.objects.all().only(\"id\", \"name\", \"release_date\"),\n    )\n)\n</code></pre> <p>Note</p> <p>Even though <code>album__release_date</code> field was not selected here, it got selected in the prefetch query later. Since Django caches known objects, we have to select it here or else it would trigger extra queries latter.</p>"},{"location":"guide/optimizer/#optimization-hints","title":"Optimization hints","text":"<p>Sometimes you will have a custom resolver which cannot be automatically optimized by the extension. Take this for example:</p> models.py<pre><code>class OrderItem(models.Model):\n    price = models.DecimalField()\n    quantity = models.IntegerField()\n\n    @property\n    def total(self) -&gt; decimal.Decimal:\n        return self.price * self.quantity\n</code></pre> types.py<pre><code>import strawberry\nimport strawberry.django\n\n@strawberry.django.type(models.OrderItem)\nclass OrderItem:\n    price: strawberry.auto\n    quantity: strawberry.auto\n    total: strawberry.auto\n</code></pre> <p>In this case, if only <code>total</code> is requested it would trigger an extra query for both <code>price</code> and <code>quantity</code> because both had their value retrievals defered by the optimizer.</p> <p>A solution in this case would be to \"tell the optimizer\" how to optimize that field:</p> types.py<pre><code>import strawberry\nimport strawberry.django\n\n@strawberry.django.type(models.OrderItem)\nclass OrderItem:\n    price: strawberry.auto\n    quantity: strawberry.auto\n    total: strawberry.auto = strawberry.django.field(\n        only=[\"price\", \"quantity\"],\n    )\n</code></pre> <p>Or if you are using a custom resolver:</p> types.py<pre><code>import decimal\n\nimport strawberry\nimport strawberry.django\n\n@strawberry.django.type(models.OrderItem)\nclass OrderItem:\n    price: strawberry.auto\n    quantity: strawberry.auto\n\n    @strawberry.django.field(only=[\"price\", \"quantity\"])\n    def total(self, root: models.OrderItem) -&gt; decimal.Decimal:\n        return root.price * root.quantity  # or root.total directly\n</code></pre> <p>The following options are accepted for optimizer hints:</p> <ul> <li><code>only</code>: a list of fields in the same format as accepted by   QuerySet.only()</li> <li><code>select_related</code>: a list of relations to join using   QuerySet.select_related()</li> <li><code>prefetch_related</code>: a list of relations to prefetch using   QuerySet.prefetch_related().   The options here are strings or a callable in the format of <code>Callable[[Info], Prefetch]</code>   (e.g. <code>prefetch_related=[lambda info: Prefetch(...)]</code>)</li> <li><code>annotate</code>: a dict of expressions to annotate using   QuerySet.annotate().   The keys of this dict are strings,   and each value is a Query Expression   or a callable in the format of <code>Callable[[Info], BaseExpression]</code>   (e.g. <code>annotate={\"total\": lambda info: Sum(...)}</code>)</li> </ul>"},{"location":"guide/optimizer/#optimization-hints-on-model-modelproperty","title":"Optimization hints on model (ModelProperty)","text":"<p>It is also possible to include type hints directly in the models' <code>@property</code> to allow it to be resolved with <code>auto</code>, while the GraphQL schema doesn't have to worry about its internal logic.</p> <p>For that this integration provides 2 decorators that can be used:</p> <ul> <li><code>strawberry_django.model_property</code>: similar to <code>@property</code> but accepts optimization hints</li> <li><code>strawberry_django.cached_model_property</code>: similar to <code>@cached_property</code> but accepts   optimization hints</li> </ul> <p>The example in the previous section could be written using <code>@model_property</code> like this:</p> models.py<pre><code>from strawberry_django import model_property\n\nclass OrderItem(models.Model):\n    price = models.DecimalField()\n    quantity = models.IntegerField()\n\n    @model_property(only=[\"price\", \"quantity\"])\n    def total(self) -&gt; decimal.Decimal:\n        return self.price * self.quantity\n</code></pre> types.py<pre><code>import strawberry\nimport strawberry.django\n\n@strawberry.django.type(models.OrderItem)\nclass OrderItem:\n    price: strawberry.auto\n    quantity: strawberry.auto\n    total: strawberry.auto\n</code></pre> <p><code>total</code> now will be properly optimized since it points to a <code>@model_property</code> decorated attribute, which contains the required information for optimizing it.</p>"},{"location":"guide/ordering/","title":"Ordering","text":"<p>Note</p> <p>This API may change in the future.</p> types.py<pre><code>@strawberry.django.order(models.Color)\nclass ColorOrder:\n    name: auto\n\n@strawberry.django.order(models.Fruit)\nclass FruitOrder:\n    name: auto\n    color: ColorOrder\n</code></pre> <p>The code above generates the following schema:</p> schema.graphql<pre><code>enum Ordering {\n  ASC\n  DESC\n}\n\ninput ColorOrder {\n  name: Ordering\n}\n\ninput FruitOrder {\n  name: Ordering\n  color: ColorOrder\n}\n</code></pre>"},{"location":"guide/ordering/#adding-orderings-to-types","title":"Adding orderings to types","text":"<p>All fields and mutations inherit orderings from the underlying type by default. So, if you have a field like this:</p> types.py<pre><code>@strawberry.django.type(models.Fruit, order=FruitOrder)\nclass Fruit:\n    ...\n</code></pre> <p>The <code>fruits</code> field will inherit the <code>filters</code> of the type same same way as if it was passed to the field.</p>"},{"location":"guide/ordering/#adding-orderings-directly-into-a-field","title":"Adding orderings directly into a field","text":"<p>Orderings added into a field override the default filters of this type.</p> schema.py<pre><code>@strawberry.type\nclass Query:\n    fruit: Fruit = strawberry.django.field(order=FruitOrder)\n</code></pre>"},{"location":"guide/pagination/","title":"Pagination","text":""},{"location":"guide/pagination/#default-pagination","title":"Default pagination","text":"<p>An interface for limit/offset pagination can be use for basic pagination needs:</p> types.py<pre><code>@strawberry.django.type(models.Fruit, pagination=True)\nclass Fruit:\n    name: auto\n</code></pre> schema.graphql<pre><code>query {\n  fruits(pagination: { offset: 0, limit: 2 }) {\n    name\n    color\n  }\n}\n</code></pre> <p>There is not default limit defined. All elements are returned if no pagination limit is defined.</p>"},{"location":"guide/pagination/#relay-pagination","title":"Relay pagination","text":"<p>For more complex scenarios, a cursor pagination would be better. For this, use the relay integration to define those.</p>"},{"location":"guide/permissions/","title":"Permissions","text":"<p>This integration exposes a field extension to extend fields into using the Django's Permissioning System for checking for permissions.</p> <p>It supports protecting any field for cases like:</p> <ul> <li>The user is authenticated</li> <li>The user is a superuser</li> <li>The user or a group they belongs to has a given permission</li> <li>The user or the group they belongs has a given permission to the resolved value</li> <li>The user or the group they belongs has a given permission to the parent of the field</li> <li>etc</li> </ul>"},{"location":"guide/permissions/#how-it-works","title":"How it works","text":"<pre><code>graph TD\n  A[Extension Check for Permissions] --&gt; B;\n  B[User Passes Checks] --&gt;|Yes| BF[Return Resolved Value];\n  B --&gt;|No| C;\n  C[Can return 'OperationInfo'?] --&gt;|Yes| CF[Return 'OperationInfo'];\n  C --&gt;|No| D;\n  D[Field is Optional] --&gt;|Yes| DF[Return 'None'];\n  D --&gt;|No| E;\n  E[Field is a 'List'] --&gt;|Yes| EF[Return an empty 'List'];\n  E --&gt;|No| F;\n  F[Field is a relay `Connection`] --&gt;|Yes| FF[Return an empty relay 'Connection'];\n  F --&gt;|No| GF[Raises 'PermissionDenied' error];</code></pre>"},{"location":"guide/permissions/#example","title":"Example","text":"types.py<pre><code>import strawberry\nimport strawberry_django\nfrom strawberry_django.permissions import (\n    IsAuthenticated,\n    HasPerm,\n    HasRetvalPerm,\n)\n\n\n@strawberry.type\nclass SomeType:\n    login_required_field: RetType = strawberry_django.field(\n        # will check if the user is authenticated\n        extensions=[IsAuthenticated()],\n    )\n    perm_required_field: OtherType = strawberry_django.field(\n        # will check if the user has `\"some_app.some_perm\"` permission\n        extensions=[HasPerm(\"some_app.some_perm\")],\n    )\n    obj_perm_required_field: OtherType = strawberry_django.field(\n        # will check the permission for the resolved value\n        extensions=[HasObjPerm(\"some_app.some_perm\")],\n    )\n</code></pre>"},{"location":"guide/permissions/#available-options","title":"Available Options","text":"<p>Available options are:</p> <ul> <li><code>IsAuthenticated</code>: Checks if the user is authenticated (i.e. <code>user.is_autenticated</code>)</li> <li><code>IsStaff</code>: Checks if the user is a staff member (i.e. <code>user.is_staff</code>)</li> <li><code>IsSuperuser</code>: Checks if the user is a superuser (i.e. <code>user.is_superuser</code>)</li> <li><code>HasPerm(perms: str | list[str], any_perm: bool = True)</code>: Checks if the user has any or all of   the given permissions (i.e. <code>user.has_perm(perm)</code>)</li> <li><code>HasSourcePerm(perms: str | list[str], any: bool = True)</code>: Checks if the user has any or all   of the given permissions for the root of that field (i.e. <code>user.has_perm(perm, root)</code>)</li> <li><code>HasRetvalPerm(perms: str | list[str], any: bool = True)</code>: Resolves the retval and then   checks if the user has any or all of the given permissions for that specific value   (i.e. <code>user.has_perm(perm, retval)</code>). If the return value is a list, this extension   will filter the return value, removing objects that fails the check (check below for more   information regarding other possibilities).</li> </ul> <p>Note</p> <p>The <code>HasObjPerm</code> extension requires having an authentication backend which supports resolving object permissions. This lib is works out of the box with django-guardian, so if you are using it you don't need to do anything else.</p>"},{"location":"guide/permissions/#no-permission-handling","title":"No Permission Handling","text":"<p>When the condition fails, the following will be returned on the field (following this priority):</p> <ol> <li><code>OperationInfo</code>/<code>OperationMessage</code> if those types are allowed at the return type</li> <li><code>null</code> in case the field is not mandatory (e.g. <code>String</code> or <code>[String]</code>)</li> <li>An empty list in case the field is a list (e.g. <code>[String]!</code>)</li> <li>An empty <code>Connection</code> in case the return type is a relay connection</li> <li>Otherwise, an error will be raised</li> </ol>"},{"location":"guide/permissions/#custom-permissions-checking","title":"Custom Permissions Checking","text":"<p>You can create your own permission checking extension by subclassing <code>DjangoPermissionExtension</code> and implementing your own <code>resolve_for_user</code> method.</p>"},{"location":"guide/queries/","title":"Queries","text":"<p>Queries can be written using <code>strawberry.django.field()</code> to load the fields defined in the <code>types.py</code> file.</p> <pre><code>#schema.py\n\nimport strawberry\n\nfrom .types import Fruit\n\n@strawberry.type\nclass Query:\n\n    Fruit: Fruit = strawberry.django.field()\n    Fruits: list[Fruit] = strawberry.django.field()\n\nschema = strawberry.Schema(query=Query)\n</code></pre> <p>Tip</p> <p>You must name your query class \"Query\" or decorate it with <code>@strawberry.type(name=\"Query\")</code> for the single query default primary filter to work</p> <p>For the single queries (like <code>Fruit</code> above), Strawberry comes with a default primary key search filter in the GraphiQL interface. The query <code>Fruits</code> gets all the objects in the Fruits by default. To query specific sets of objects a filter need to be added in the <code>types.py</code> file.</p>"},{"location":"guide/relay/","title":"Relay Support","text":"<p>You can use the official strawberry relay integration directly with django types like this:</p> types.py<pre><code>import strawberry\nimport strawberry_django\nfrom strawberry_django.relay import ListConnectionWithTotalCount\n\n\nclass Fruit(models.Model):\n    ...\n\n\n@strawberry_django.type(Fruit)\nclass FruitType(relay.Node):\n    ...\n\n\n@strawberry.type\nclass Query:\n    # Option 1: Default relay without totalCount\n    # This is the default strawberry relay behaviour.\n    # NOTE: you need to use strawberry_django.connection() - not the default strawberry.relay.connection()\n    fruit: strawberry.relay.ListConnection[FruitType] = strawberry_django.connection()\n\n    # Option 2: Strawberry django also comes with ListConnectionWithTotalCount\n    # this will allow you to get total-count on your query.\n    fruit_with_total_count: ListConnectionWithTotalCount[\n        FruitType\n    ] = strawberry_django.connection()\n\n    # Option 3: You can manually create resolver by your method manually.\n    @strawberry_django.connection(ListConnectionWithTotalCount[FruitType])\n    def fruit_with_custom_resolver(self) -&gt; List[SomeModel]:\n        return Fruit.objects.all()\n</code></pre> <p>Behind the scenes this extension is doing the following for you:</p> <ul> <li>Automatically resolve the <code>relay.NodeID</code> field using the model's pk</li> <li>Automatically generate resolves for connections that doesn't define one. For example,   <code>some_model_conn</code> and <code>some_model_conn_with_total_count</code> will both define a custom resolver   automatically that returns <code>SomeModel.objects.all()</code>.</li> <li>Integrate connection resolution with all other features available in this lib. For example,   filters, ordering and   permissions can be used together with connections defined   by strawberry django.</li> </ul> <p>You can also define your own <code>relay.NodeID</code> field and your resolve, in the same way as <code>some_model_conn_with_resolver</code> is doing. In those cases, they will not be overridden.</p> <p>Tip</p> <p>If you are only working with types inheriting from <code>relay.Node</code> and <code>GlobalID</code> for identifying objects, you might want to set <code>MAP_AUTO_ID_AS_GLOBAL_ID=True</code> in your strawberry django settings to make sure <code>auto</code> fields gets mapped to <code>GlobalID</code> on types and filters.</p> <p>Also, this lib exposes a <code>strawberry_django.relay.ListConnectionWithTotalCount</code>, which works the same way as <code>strawberry.relay.ListConnection</code> does, but also exposes a <code>totalCount</code> attribute in the connection.</p> <p>For more customization options, like changing the pagination algorithm, adding extra fields to the <code>Connection</code>/<code>Edge</code> type, take a look at the official strawberry relay integration as those are properly explained there.</p>"},{"location":"guide/resolvers/","title":"Custom Resolvers","text":"<p>Basic resolvers are generated automatically once the types are declared.</p> <p>However it is possible to override them with custom resolvers.</p>"},{"location":"guide/resolvers/#sync-resolvers","title":"Sync resolvers","text":"<p>Sync resolvers can be used in both ASGI/WSGI and will be automatically wrapped in <code>sync_to_async</code> when running async.</p> types.py<pre><code>from strawberry import auto\nfrom typing import List\nfrom . import models\n\n@strawberry.django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n\n    @strawberry_django.field\n    def fruits(self) -&gt; List[Fruit]:\n        return self.fruits.objects.filter(...)\n</code></pre>"},{"location":"guide/resolvers/#async-resolvers","title":"Async resolvers","text":"<p>Async resolvers can be used when running using ASGI.</p> types.py<pre><code>from strawberry import auto\nfrom typing import List\nfrom . import models\nfrom asgiref.sync import sync_to_async\n\n@strawberry.django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n\n    @strawberry.django.field\n    async def fruits(self) -&gt; List[Fruit]:\n        return sync_to_async(list)(self.fruits.objects.filter(...))\n</code></pre>"},{"location":"guide/resolvers/#optimizing-resolvers","title":"Optimizing resolvers","text":"<p>When using custom resolvers together with the Query Optimizer Extension you might need to give it a \"hint\" on how to optimize that field</p> <p>Take a look at the optimization hints docs for more information about this topic.</p>"},{"location":"guide/resolvers/#issues-with-resolvers","title":"Issues with Resolvers","text":"<p>It is important to note that overriding resolvers also removes default capabilities (e.g. <code>Pagination</code>, <code>Filter</code>), exception for relay connections. You can however still add those by hand and resolve them:</p> types.py<pre><code>import strawberry\nimport strawberry_django\nfrom strawberry.django import auto\nfrom . import models\n\n\n@strawberry.django.filter(models.Fruit, lookups=True)\nclass FruitFilter:\n    id: auto\n    name: auto\n\n\n@strawberry.django.type(models.Fruit, order=FruitOrder)\nclass Fruit:\n    id: auto\n    name: auto\n\n\n@strawberry.django.type(models.Fruit, is_interface=True)\nclass Fruit:\n    id: auto\n    name: auto\n\n\n@strawberry.type\nclass Query:\n    @strawberry.django.field\n    def fruits(\n        self,\n        filters: FruitFilter | None = strawberry.UNSET,\n        order: FruitOrder | None = strawberry.UNSET,\n    ) -&gt; list[Fruit]\n        qs = models.fruit.objects.all()\n\n        # apply filters if defined\n        if filters is not strawberry.UNSET:\n            qs = strawberry_django.filters.apply(filters, qs, info)\n\n        # apply ordering if defined\n        if order is not strawberry.UNSET:\n            qs = strawberry_django.ordering.apply(filters, qs)\n\n        return qs\n</code></pre>"},{"location":"guide/settings/","title":"Django Settings","text":"<p>Certain features of this library are configured using custom Django settings.</p>"},{"location":"guide/settings/#strawberry_django","title":"STRAWBERRY_DJANGO","text":"<p>A dictionary with the following optional keys:</p> <ul> <li> <p><code>FIELD_DESCRIPTION_FROM_HELP_TEXT</code> (default: <code>False</code>)</p> <p>If True, GraphQL field's description   will be fetched from the corresponding Django model field's   <code>help_text</code> attribute.   If a description is provided using field customization,   that description will be used instead.</p> </li> <li> <p><code>TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING</code> (default: <code>False</code>)</p> <p>If True, GraphQL type descriptions   will be fetched from the corresponding Django model's   docstring.   If a description is provided using the   <code>strawberry_django.type</code> decorator,   that description will be used instead.</p> </li> <li> <p><code>MUTATIONS_DEFAULT_ARGUMENT_NAME</code> (default: <code>\"data\"</code>)</p> <p>Change the CUD mutations' default   argument name when no option is passed (e.g. to <code>\"input\"</code>)</p> </li> <li> <p><code>MUTATIONS_DEFAULT_HANDLE_ERRORS</code> (default: <code>False</code>)</p> <p>Set the default behaviour of the   Django Errors Handling   when no option is passed.</p> </li> <li> <p><code>GENERATE_ENUMS_FROM_CHOICES</code> (default: <code>False</code>)</p> <p>If True, fields with <code>choices</code> will have automatically generate   an enum of possibilities instead of being exposed as <code>String</code>.   A better option is to use   Django's TextChoices/IntegerChoices   with the django-choices-field integration.</p> </li> <li> <p><code>MAP_AUTO_ID_AS_GLOBAL_ID</code> (default: <code>False</code>)</p> <p>If True, <code>auto</code> fields that refer to model ids will be mapped to <code>relay.GlobalID</code>   instead of <code>strawberry.ID</code>. This is mostly useful if all your model types inherit   from <code>relay.Node</code> and you want to work only with <code>GlobalID</code>.</p> </li> </ul> <p>These features can be enabled by adding this code to your <code>settings.py</code> file.</p> settings.py<pre><code>STRAWBERRY_DJANGO = {\n    \"FIELD_DESCRIPTION_FROM_HELP_TEXT\": True,\n    \"TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING\": True,\n    \"MUTATIONS_DEFAULT_ARGUMENT_NAME\": \"input\",\n    \"MUTATIONS_DEFAULT_HANDLE_ERRORS\": True,\n    \"GENERATE_ENUMS_FROM_CHOICES\": False,\n    \"MAP_AUTO_ID_AS_GLOBAL_ID\": True,\n}\n</code></pre>"},{"location":"guide/subscriptions/","title":"Subscriptions","text":""},{"location":"guide/subscriptions/#subscriptions","title":"Subscriptions","text":"<p>Subscriptions are supported using the Strawberry Django Channels integration.</p> <p>Check its docs to know how to use it.</p>"},{"location":"guide/types/","title":"Defining Types","text":""},{"location":"guide/types/#output-types","title":"Output types","text":"<p>Note</p> <p>It is highly recommended to enable the Query Optimizer Extension for improved performance and avoid some common pitfalls (e.g. the <code>n+1</code> issue)</p> <p>Output types are generated from models. The <code>auto</code> type is used for field type auto resolution. Relational fields are described by referencing to other types generated from Django models. A many-to-many relation is described with the <code>typing.List</code> type annotation. <code>strawberry.django</code> will automatically generate resolvers for relational fields. More information about that can be read from resolvers page.</p> types.py<pre><code>from strawberry import auto\nfrom typing import List\n\n@strawberry.django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n    color: \"Color\"\n\n@strawberry.django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n    fruits: List[Fruit]\n</code></pre>"},{"location":"guide/types/#input-types","title":"Input types","text":"<p>Input types can be generated from Django models using the <code>strawberry.django.input</code> decorator. The first parameter is the model which the type is derived from.</p> types.py<pre><code>@strawberry.django.input(models.Fruit)\nclass FruitInput:\n    id: auto\n    name: auto\n    color: \"ColorInput\"\n</code></pre> <p>A partial input type, in which all fields are optional, is generated by setting the <code>partial</code> keyword argument in <code>input</code> to <code>True</code>. Partial input types can be generated from existing input types through class inheritance.</p> types.py<pre><code>@strawberry.django.input(models.Color, partial=True)\nclass FruitPartialInput(FruitInput):\n    color: List[\"ColorPartialInput\"]\n\n@strawberry.django.input(models.Color, partial=True)\nclass ColorPartialInput:\n    id: auto\n    name: auto\n    fruits: List[FruitPartialInput]\n</code></pre>"},{"location":"guide/types/#types-from-django-models","title":"Types from Django models","text":"<p>Django models can be converted to <code>strawberry</code> Types with the <code>strawberry_django.type</code> decorator. Custom descriptions can be added using the <code>description</code> keyword argument (See: <code>strawberry.type</code> decorator API).</p> types.py<pre><code>import strawberry\n\n@strawberry.django.type(models.Fruit, description=\"A tasty snack\")\nclass Fruit:\n    ...\n</code></pre>"},{"location":"guide/types/#adding-fields-to-the-type","title":"Adding fields to the type","text":"<p>By default, no fields are implemented on the new type. Check the documentation on How to define Fields for that.</p>"},{"location":"guide/types/#customizing-the-returned-queryset","title":"Customizing the returned <code>QuerySet</code>","text":"<p>Warning</p> <p>By doing this you are modifying all automatic <code>QuerySet</code> generation for any field that returns this type. Ideally you will want to define your own resolver instead, which gives you more control over it.</p> <p>By default, a <code>strawberry_django</code> type will get data from the default manager for its Django Model. You can implement a custom <code>get_queryset</code> classmethod to your type to do some extra processing to the default queryset, like filtering it further.</p> types.py<pre><code>@strawberry.django.type(models.Fruit)\nclass Berry:\n\n    @classmethod\n    def get_queryset(cls, queryset, info, **kwargs):\n        return queryset.filter(name__contains=\"berry\")\n</code></pre> <p>The <code>get_queryset</code> classmethod is given a <code>QuerySet</code> to filter and a <code>strawberry</code> <code>Info</code> object containing details about the request.</p> <p>You can use that <code>info</code> parameter to, for example, limit access to results based on the current user in the request:</p> types.py<pre><code>@strawberry.django.type(models.Fruit)\nclass Berry:\n\n    @classmethod\n    def get_queryset(cls, queryset, info, **kwargs):\n        if not info.context.request.user.is_staff:\n            # Restrict access to top secret berries if the user is not a staff member\n            queryset = queryset.filter(is_top_secret=False)\n        return queryset.filter(name__contains=\"berry\")\n</code></pre> <p>Note</p> <p>Another way of limiting this is by using the PermissionExtension provided by this lib.</p> <p>The <code>kwargs</code> dictionary can include other parameters that were added in a <code>@strawberry.django.type</code> definition like filters or pagination.</p>"},{"location":"guide/unit-testing/","title":"Unit testing","text":"<p>Unit testing can be done by following the strawberry's testing docs reference.</p> <p>This lib also provides a <code>TestClient</code> and an <code>AsyncTestClient</code> that makes it easier to run tests by mimicing a call to your API.</p> <p>For example, suppose you have a <code>me</code> query which returns the currently logged in user or <code>None</code> in case it is not authenticated. You could test it like this:</p> <pre><code>from strawberry_django.test.client import TestClient\n\n\ndef test_me_unauthenticated(db):\n    client = TestClient(\"/graphql\")\n    res = gql_client.query(\"\"\"\n      query TestQuery {\n        me {\n          pk\n          email\n          firstName\n          lastName\n        }\n      }\n    \"\"\")\n    assert res.errors is None\n    assert res.data == {\"me\": None}\n\n\ndef test_me_authenticated(db):\n    user = User.objects.create(...)\n\n    client = TestClient(\"/graphql\")\n    res = client.query(\"\"\"\n      query TestQuery {\n        me {\n          pk\n          email\n          firstName\n          lastName\n        }\n      }\n    \"\"\")\n    assert res.errors is None\n    assert res.data == {\n        \"me\": {\n            \"pk\": user.pk,\n            \"email\": user.email,\n            \"firstName\": user.first_name,\n            \"lastName\": user.last_name,\n        },\n    }\n</code></pre>"},{"location":"guide/views/","title":"Serving the API","text":"<p>Strawberry works both with ASGI (async) and WSGI (sync). This integration supports both ways of serving django.</p> <p>ASGI is the best way to enjoy everything that strawberry has to offer and is highly recommended unless you can't for some reason. By using WSGI you will be missing support for some interesting features, such as Data Loaders.</p>"},{"location":"guide/views/#serving-as-asgi-async","title":"Serving as ASGI (async)","text":"<p>Expose the strawberry API when using ASGI by setting your urls.py like this:</p> urls.py<pre><code>from django.urls import path\nfrom strawberry.django.views import AsyncGraphQLView\n\nfrom .schema import schema\n\nurlpatterns = [\n    path('graphql', AsyncGraphQLView.as_view(schema=schema)),\n]\n</code></pre>"},{"location":"guide/views/#serving-wsgi-sync","title":"Serving WSGI (sync)","text":"<p>Expose the strawberry API when using WSGI by setting your urls.py like this:</p> urls.py<pre><code>from django.urls import path\nfrom strawberry.django.views import GraphQLView\n\nfrom .schema import schema\n\nurlpatterns = [\n    path('graphql', GraphQLView.as_view(schema=schema)),\n]\n</code></pre>"},{"location":"integrations/channels/","title":"django-channels","text":"<p>Strawberry provides an integration for django-channels to allow subscriptions to be used with django.</p> <p>Check the official strawberry django docs for more information on how to use it.</p>"},{"location":"integrations/choices-field/","title":"django-choices-field","text":"<p>This lib provides integration for enum resolution for Django's TextChoices/IntegerChoices when defining the fields using the django-choices-field lib:</p> models.py<pre><code>from django.db import models\nfrom django_choices_field import TextChoicesField\n\nclass Status(models.TextChoices):\n    ACTIVE = \"active\", \"Is Active\"\n    INACTIVE = \"inactive\", \"Inactive\"\n\nclass Company(models.Model):\n    status = TextChoicesField(\n        choices_enum=Status,\n        default=Status.ACTIVE,\n    )\n</code></pre> types.py<pre><code>import strawberry\nimport strawberry_django\n\nimport .models\n\n@strawberry_django.type(models.Company)\nclass Company:\n    status: strawberry.auto\n</code></pre> <p>The code above would generate the following schema:</p> schema.graphql<pre><code>enum Status {\n  ACTIVE\n  INACTIVE\n}\n\ntype Company {\n  status: Status\n}\n</code></pre>"},{"location":"integrations/debug-toolbar/","title":"django-debug-toolbar","text":"<p>This integration provides integration between the Django Debug Toolbar and <code>strawberry</code>, allowing it to display stats like <code>SQL Queries</code>, <code>CPU Time</code>, <code>Cache Hits</code>, etc for queries and mutations done inside the graphiql page.</p> <p>To use it, make sure you have the Django Debug Toolbar installed and configured, then change its middleware settings from:</p> settings.py<pre><code>MIDDLEWARE = [\n    ...\n    \"debug_toolbar.middleware.DebugToolbarMiddleware\",\n    ...\n]\n</code></pre> <p>To:</p> settings.py<pre><code>MIDDLEWARE = [\n    ...\n    \"strawberry_django.middlewares.debug_toolbar.DebugToolbarMiddleware\",\n    ...\n]\n</code></pre> <p>Finally, ensure app <code>\"strawberry_django\"</code> is added to your <code>INSTALLED_APPS</code> in Django settings.</p>"},{"location":"integrations/guardian/","title":"django-guardian","text":"<p>This lib provides integration for per-object-permissions using django-guardian.</p> <p>Check the Permission Extension Guide for more information on how to use it.</p>"}]}